#!/usr/bin/env node

if (
  !process.argv.includes("pre-commit") &&
  !process.argv.includes("post-commit")
) {
  console.log(`
▄▄▄         ▄· ▄▌ ▄▄▄· ▄▄▌
▀▄ █·▪     ▐█▪██▌▐█ ▀█ ██•
▐▀▀▄  ▄█▀▄ ▐█▌▐█▪▄█▀▀█ ██▪
▐█•█▌▐█▌.▐▌ ▐█▀·.▐█ ▪▐▌▐█▌▐▌
.▀  ▀ ▀█▄▀▪  ▀ •  ▀  ▀ .▀▀▀
`);
}

const { spawn, spawnSync } = require("child_process");
const { existsSync } = require("fs");
const { join, delimiter, dirname } = require("path");

const basePath = join(process.cwd(), ..."pkgs/base/main.js".split("/"));
const args = process.argv.slice(2);
const nodePath = [
  join(process.cwd(), "pkgs", "base", "node_modules"),
  join(process.cwd(), "pkgs", "base", "pkgs", "bundler", "node_modules"),
].join(delimiter);

let nocache = false;

const main = async () => {
  if (!existsSync(join(process.cwd(), "node_modules"))) {
    await new Promise((resolve) => {
      const pnpm = spawn("pnpm", ["i"], { stdio: "inherit", shell: true });
      pnpm.on("exit", resolve);
    });
  }

  function exitHandler(options, exitCode) {
    global.base.kill(1)
  }

  //do something when app is closing
  process.on("exit", exitHandler.bind(null, { cleanup: true }));

  //catches ctrl+c event
  process.on("SIGINT", exitHandler.bind(null, { exit: true }));

  // catches "kill pid" (for example: nodemon restart)
  process.on("SIGUSR1", exitHandler.bind(null, { exit: true }));
  process.on("SIGUSR2", exitHandler.bind(null, { exit: true }));

  //catches uncaught exceptions
  process.on("uncaughtException", exitHandler.bind(null, { exit: true }));

  while (true) {
    if (args.includes("devbase") || !existsSync(basePath)) {
      const res = spawnSync(
        process.execPath,
        ["pkgs/base/src/builder/base.mjs", ...args],
        {
          stdio: "inherit",
          env: {
            ...process.env,
            NODE_PATH: nodePath,
          },
          cwd: process.cwd(),
        }
      );

      if (res.status === 1) {
        break;
      }
    }

    if (existsSync(basePath)) {
      await runBase();
    }
  }
};

const runBase = async () => {
  global.base = spawn(
    process.execPath,
    [
      "--enable-source-maps",
      basePath,
      ...args,
      nocache ? "nocache" : "",
    ].filter((e) => e),
    {
      env: {
        ...process.env,
        NODE_PATH: join(dirname(basePath), "node_modules"),
      },
      cwd: process.cwd(),
      stdio: "inherit",
    }
  );

  const res = await new Promise((resolve) => {
    global.base.on("exit", resolve);
  });

  if (res.status === 99) nocache = true;
  else nocache = false;
  if (res.status === 1) {
    process.exit(1);
  }
};

main();
